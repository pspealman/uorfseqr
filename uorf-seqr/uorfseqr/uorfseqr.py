# -*- coding: utf-8 -*-
"""
Created on Thu Aug 16 16:39:54 2018

uorfseqr
Description:
This wrapper acts as an interface for the core uORFs scripts created by Armaghan Naik. 

@author: Pieter Spealman
"""
import argparse
import subprocess
import os

def output_handler(output):
    if len(output.strip()) > 1:
        print(output)

#function handles help commands
def help_dialog():
    monolog=('Manual for uorfseqr\n'+
    '#=============================================================#\n'+
    'Lead programmer: Armaghan Naik anaik@cmu.edu\n'+
    'Assistant: Pieter Spealman pspsealman@cmu.edu \n'+
    'Release version: 0.1 \n'+
    'Release date: 08.18.18 \n'+
    'Description:\n\tuORF-seqr is novel machine learning approach that measures features of\n'+
    '\texpression (mRNA, Ribosome profiling data) of a set of molecularly validated\n'+
    '\tuORFs across triplicate datasets. These features are then used to predict\n'+
    '\tnovel uORFs.\n'+
    'Citation:\n\tSpealman, P. and Naik, A. et al. \n'+
    '\tConserved non-AUG uORFs revealed by a novel regression analysis of ribosome profiling data.\n'+
    '\tGenome Research 28, 214â€“222 (2018).\n'+
    '\tdoi: 10.1101/gr.221507.117\n'+
    'Copyright MIT License, 2017 Armaghan Naik, Pieter Spealman'
    '#=============================================================#\n'+
    'For demonstration use:\n\t python uorfseqr.py -demo\n'+
    'To run a install test using defaults, use:\n\t python uorfseqr.py -test\n'+
    '')
    print(monolog)
   
def demo():
    monolog = ('\tStep 1. -preprocess command processes genome.\n')
    print(monolog)
    monolog = ('\t\tUsage:\n\tpython uorfseqr.py -pre -genome_name <str> -fa <path to reference fasta file>\n'+
    '\t\tExample:\n\tpython uorfseqr.py -pre -genome_name s_cerervisiae -fa data/reference_genomes/Scer_SacCer3.fa\n')
    print(monolog)

    monolog = ('\tStep 2. -quantify command caluclates feature weights of known uORFs.\n')
    print(monolog)
    monolog = ('\t\tUsage:\n\tpython uorfseqr.py -quantify -genome_name <str> -samples <sample _name> <path to sample RPF.bam> <path to sample mRNA.mRNA> -o <output_dir>\n'+
    '\t\tExample:\n\tpython uorfseqr.py -quantify -genome_name s_cerervisiae -samples Scer_A ../data/bam/Scer_A_RPF_10.bam ../data/bam/Scer_A_mRNA_10.bam Scer_B ../data/bam/Scer_B_RPF_10.bam ../data/bam/Scer_B_mRNA_10.bam Scer_C ../data/bam/Scer_C_RPF_10.bam ../data/bam/Scer_C_mRNA_10.bam -o scer.demo')
    print(monolog)

    monolog = ('\tTesting Step 3. -predict command generates predictions using the weighted features generated by the quantify command.\n')
    print(monolog)
    monolog = ('\t\tUsage:\n\tpython uorfseqr.py -predict -i <previous output_dir> -o <str>\n'+
    '\t\tExample:\n\tpython uorfseqr.py -predict -i scer.demo -o scer.demo/results\n')
    print(monolog)    
    
def test():
    monolog = ('=== Currently Testing uprfseqr.py ===')
    print(monolog)

    monolog = ('\tTesting Step 1. -preprocess command processes genome.\n')
    print(monolog)    
    bashCommand = ('python uorfseqr.py -preprocess -genome_name s_cerervisiae -fa data/reference_genomes/Scer_SacCer3.fa')
    print(bashCommand)
    output_handler(subprocess.check_output([bashCommand],stderr=subprocess.STDOUT,shell=True))
    
    monolog = ('\tTesting Step 2. -quantify command caluclates feature weights of known uORFs.\n')
    print(monolog)    
    bashCommand = ('python uorfseqr.py -quantify -o scer.demo -genome_name s_cerervisiae -samples Scer_A ../data/bam/Scer_A_RPF_10.bam ../data/bam/Scer_A_mRNA_10.bam Scer_B ../data/bam/Scer_B_RPF_10.bam ../data/bam/Scer_B_mRNA_10.bam Scer_C ../data/bam/Scer_C_RPF_10.bam ../data/bam/Scer_C_mRNA_10.bam')
    print(bashCommand)
    output_handler(subprocess.check_output([bashCommand],stderr=subprocess.STDOUT,shell=True))
    
    
    monolog = ('\tTesting Step 3. -predict command generates predictions using the weighted features generated by the quantify command.\n')
    print(monolog)    
    bashCommand = ('python uorfseqr.py -predict -i scer.demo -o scer.demo/results')
    print(bashCommand)
    output_handler(subprocess.check_output([bashCommand],stderr=subprocess.STDOUT,shell=True))

### Argparser definitions        
parser = argparse.ArgumentParser()
#handle help_dialog
parser.add_argument('-man',"--manual", action='store_true')
parser.add_argument('-demo',"--demo",action='store_true')
parser.add_argument('-test',"--test",action='store_true')

#handle preprocess task
parser.add_argument('-preprocess',"--preprocess_genome", action='store_true')
parser.add_argument('-genome_name',"--genome_name")
parser.add_argument('-fa',"--fa_file")

#handle quantify task
parser.add_argument('-quantify',"--quantify_features", action='store_true')
parser.add_argument('-gff',"--gff_file")
parser.add_argument('-filter',"--filter_uorfs")
parser.add_argument('-known',"--known_uorfs")
parser.add_argument('-samples', '--sample_list', nargs='+')
parser.add_argument('-max_rpf','--max_rpf_size')
parser.add_argument('-min_rpf','--min_rpf_size')
parser.add_argument('-non_start', '--non_start_ncc', nargs='+')
parser.add_argument('-morf_mask', '--morf_mask')
parser.add_argument('-min_utr', '--too_small_utr')
parser.add_argument('-min_rpf_ct', '--min_rpf_ct')
parser.add_argument('-kozak_seq','--kozak_seq')
parser.add_argument('-kozak_cutoff', '--kozak_cutoff')
parser.add_argument('-in_phase_cutoff','--in_phase_cutoff')
parser.add_argument('-o',"--output_dir")

#handle predict task
parser.add_argument('-predict',"--predict_uorfs", action='store_true')
parser.add_argument('-i',"--input_dir")
#
args = parser.parse_args()
###

if args.manual:
    help_dialog()
    
if args.demo:
    demo()
    
if args.test:
    test()

###        
def make_dir(dir_name):
    bash_command = ('mkdir -p {}').format(dir_name)
    output = subprocess.check_output([bash_command],stderr=subprocess.STDOUT,shell=True)
    print(output)
    
def dir_handler()  :
    original_wd = os.getcwd()
        
    if args.preprocess_genome:
        cache = args.genome_name
        if cache[-1] != '/':
            #cache = cache + '/'
            outdir_name = str(original_wd + '/data/processed_genomes/' + cache)
        else:
            outdir_name = cache
        
        make_dir(outdir_name)
    
        return(outdir_name, original_wd)
        
    if args.quantify_features:
        cache = args.output_dir
        if cache[-1] != '/':
            outdir_name = str(original_wd + '/' + cache)
        else:
            outdir_name = cache
        
        make_dir(outdir_name)
            
        return(outdir_name, original_wd)
      
def json_list_formater(original_list):
    #json format requires double quotes in lists.
    ct = 0
    output_str = ""
    for each in original_list:
        if ct < len(original_list)-1:
            each = str('"'+each+'",')
        else:
            each = str('"'+each+'"')
        output_str+=each
        ct+=1
    return(output_str)

###

### Handle inputs and defaults: 
#
#users can set their own gff file to define 5'UTRs (aka. transcript leaders), 3'UTRs,
# Transcription start sites, poly-a sites, and main orf coordinates.
# Otherwise the standard gff for S.cerevisiae (from Spealman and Naik, Genome Research, 2017) is loaded.
#
if args.gff_file:
    gff_file = args.gff_file
else:
    gff_file = '../data/reference_genomes/saccharomyces_cerevisiae.gff'

#users can set their own genes or regions to be filtered by loading a bed file
# otherwise the scer_baduorf file can be loaded
# NOTE: if it is desired that no genes or regions be filtered a blank file should 
#  be loaded instead
#
if args.filter_uorfs:
    filter_uorfs = args.filter_uorfs
else:
    filter_uorfs = '../data/labelled_uorfs/scer_baduorf.bed'
    
# users can set their own list of labelled positive uORFs by loading a bed file containing
# the uORF from start codon to stop codon and strand.
# Otherwise the STANDARD-golden bed file is loaded. This file contains 17 molecularly 
#    validated uORFs identified in S.cerevisiae before 2017.
# A longer list of containing the 432 predicted S.cerevisae uORFs from Spealman and Naik (Genome Research, 2017)
#   is also available as 'data/labelled_uorfs/Spealman_Naik_2017.bed'
#         
if args.known_uorfs:
    known_uorfs = args.known_uorfs
else:
    known_uorfs = '../data/labelled_uorfs/STANDARD-golden.bed'

#handles maximum RPF size as input, else defaults to 33bp
if args.max_rpf_size:
    maxseqlen = int(args.max_rpf_size)
else:
    maxseqlen = 33

#handles minimum RPF size as input, else defaults to 27bp
if args.min_rpf_size:
    minseqlen = int(args.min_rpf_size)
else:
    minseqlen = 27

#handles triplet nucleotids that will not be considered as start codons:
if args.non_start_ncc:
    ignore_list = args.non_start_ncc
    
else:
    ignore_list = ["AGG","AAG"]
    
#json format requires double quotes in lists.
ignore_str = json_list_formater(ignore_list)

#The user can define the canonical Kozak sequence that is used for evaluating the
# Kozak context around any potential start codon.
# The default setting is the Kozak consensus sequence defined for S. cerevisiae
if args.kozak_seq:
    kozak_seq = args.kozak_seq
else:
    kozak_seq = '"AAAAAAATGT"'
    
#The user can set the Kozak distance cutoff for evaluation.
# Otherwise it is set to 0.0001
if args.kozak_cutoff:
    kozak_cutoff = float(args.skozak_cutoff)
else:
    kozak_cutoff = 0.0001

#The user can set the cutoff for in_phase (FFT) ribosome densities.
# Otherwise this value is set to 1.0
if args.in_phase_cutoff:
    in_phase_cutoff = float(args.in_phase_cutoff)
else:
    in_phase_cutoff = 1.0
    
#allows for the user to set the main orf mask, the region upstream of the main orf
# TIS that is masked out so as to not count ribosomes actually initiating at the 
# main ORF TIS. 
if args.morf_mask:
    ribosome_overhang = int(args.morf_mask)
else:
    ribosome_overhang = 15

#allows for the user to set the minimum length of UTR (transcript leader), 
# otherwise set to 15bp
if args.too_small_utr:
    too_small_utr =  int(args.too_small_utr)
else:
    too_small_utr = 15

#allows for the user to set the minimum number of rpf reads required.
# otherwise set to 3 read minimum     
if args.min_rpf_ct:
    min_rpf = int(args.min_rpf_ct)
else:
    min_rpf = 3

##
##
##

# Task Preprocess - handles the initial setup of genome, seqeunce scans, etc.
if args.preprocess_genome:
    outdir_name, original_wd = dir_handler()      
    
    os.chdir(outdir_name)
    
    outfile = open('preprocess.cmd','w')
    
    is_fa_file = args.fa_file
    if is_fa_file[0]!='/':
        is_fa_file = str(original_wd + '/'+ args.fa_file)
    
    outline = ('genome {}\n'+
    'cachedir CACHE').format(is_fa_file)
    outfile.write(outline)
    
    outfile.close()
    
    bash_command = ('python ../../../analysis/preprocess_genome.py preprocess.cmd')
    output_handler(subprocess.check_output([bash_command],stderr=subprocess.STDOUT,shell=True))
    
    os.chdir(original_wd)

# Task Quantify - handles feature scoring and identification of potential uORFs 
if args.quantify_features:    
    def parse_sample_list(analysis_file, runmode):
        
        if args.sample_list:
            if len(args.sample_list)%3!= 0:
                print('Each sample requires a Name, RPF bam file, and RNA bam file.')
                
            else:
                if runmode == 'names':
                    name_list = []
                    
                    for i in range(int(len(args.sample_list)/3)):
                        name_list.append(args.sample_list[i*3])
                    
                    return(name_list)
                    
                if runmode == 'deets':
                    ct = 0
                    for i in range(int(len(args.sample_list)/3)):
                        name = args.sample_list[i*3]
                        RPF_name = args.sample_list[(i*3)+1]
                        RNA_name = args.sample_list[(i*3)+2]
                        head_bracket = '\t\t{\n'
                        sample_midline = ('\t\t\t"name":"{}",\n\t\t\t"RPF":"{}",\n\t\t\t"mRNA":"{}"\n').format(name,RPF_name,RNA_name)
                        if ct < (len(args.sample_list)/3)-1:
                            tail_bracket = '\t\t},\n'
                        else:
                            tail_bracket = '\t\t}\n'
                        sample_outline = str(head_bracket + sample_midline + tail_bracket)
                        
                        analysis_file.write(sample_outline)
                        ct+=1
                    return('Samples loaded in:\n\t\t analysis.json')
                    
        else:
            print('A sample list must be provided.\nEach sample requires a Name, RPF bam file, and RNA bam file.\n')
            
    def write_analysis_json(outdir_name):        
        analysis_file = open('analysis.json','w')

        sample_name_list = parse_sample_list(analysis_file, 'names')
        fixed_sample_name_str = json_list_formater(sample_name_list)
        
        prefix_str = ('\t"PREFIX":"{}/",\n').format(outdir_name)
        genome_str = ('\t"GENOME":"{}",\n').format(args.genome_name)
        
        genome_cache_str = ('\t"GENOME_CACHE":"../data/processed_genomes/{}/CACHE/",\n').format(args.genome_name)
        
        chromo_str = ('\t"chromosomes":["chrI","chrII","chrIII","chrIV","chrV","chrVI","chrVII","chrVIII","chrIX","chrX","chrXI","chrXII","chrXIII","chrXIV","chrXV","chrXVI"],\n')
        gff_str = ('\t"GFF_FILE":"{}",\n').format(gff_file)
        bad_uorfs_str = ('\t"BADuORFs":"{}",\n').format(filter_uorfs)
        in_phase_str=('\t"in_phase_tolerance":1.0,\n').format(in_phase_cutoff)
        weak_str=('\t"weak_kozak_cutoff":{},\n').format(kozak_cutoff)
        kozak_str=('\t"example_kozak_sequences":[{}],\n').format(kozak_seq)
        labeled_str=('\t"labeled_data":["{}"],\n').format(known_uorfs)
        rpf_max_str=('\t"rpf_maxseqlen":{},\n').format(maxseqlen)
        rpf_min_str=('\t"rpf_minseqlen":{},\n').format(minseqlen)
        processed_dir_str=('\t"processed_dir":"processed/",\n')
        ignore_start_codons_str=('\t"ignore_start_codons":[{}],\n').format(ignore_str)
        
        sample_group = outdir_name.rsplit('/',1)[1]
        sample_head = ('\t"SAMPLE_GROUPS":\n\t[\n\t\t{\n')
        sample_mid = ('\t\t\t"groupname": "{}",\n\t\t\t"wsamples": [{}]\n').format(sample_group, fixed_sample_name_str)
        sample_tail = ('\t\t}\n\t],\n')
        sample_str = ('\t"SAMPLES":\n\t[\n')

        outline = str('{\n'+prefix_str + genome_str + genome_cache_str + chromo_str + gff_str + bad_uorfs_str + 
        in_phase_str + weak_str + kozak_str + labeled_str + rpf_max_str + rpf_min_str + processed_dir_str + 
        ignore_start_codons_str + sample_head + sample_mid + sample_tail + sample_str)        
        analysis_file.write(outline)

        parse_samples = parse_sample_list(analysis_file, 'deets')
        
        sample_close_str = ('\t],\n')
        poisson_str = ('\t"poisson_random":false,\n')
        permutation_str = ('\t"permutation_seeds":[3,5,7,11],\n')
        overhang_str = ('\t"OVERHANG_BY_RIBOSOME":{},\n').format(ribosome_overhang)
        too_small_str = ('\t"TOO_SMALL_UTR":{},\n').format(too_small_utr)
        min_rpf_str = ('\t"MIN_RPF_CONSIDERED":{},\n').format(min_rpf)
        permute_5utr_str = ('\t"PERMUTE_5pUTR":false,\n')
        permute_frame_str = ('\t"PERMUTE_FRAME":null,\n')
        force_labelled_str = ('\t"FORCE_ONLY_LABELED":false,\n')
        max_orf_skip_str = ('\t"MAX_ORF_SKIPLIST":4\n')
        
        outline = str(sample_close_str + poisson_str + permutation_str + overhang_str 
        + too_small_str + min_rpf_str + permute_5utr_str + permute_frame_str 
        + force_labelled_str + max_orf_skip_str+'}\n')        
        analysis_file.write(outline)
        
        print(parse_samples)
        
        analysis_file.close()    
        
    outdir_name, original_wd = dir_handler()
    
    outline = ('Preparing run in {}...').format(outdir_name)
    print(outline)
    
    bash_command = ('mkdir -p {}').format(outdir_name)
    output_handler(subprocess.check_output([bash_command],stderr=subprocess.STDOUT,shell=True))
        
    bash_command = ('cp analysis/runprocess.py {}/.').format(outdir_name)
    output_handler(subprocess.check_output([bash_command],stderr=subprocess.STDOUT,shell=True))

    bash_command = ('cp analysis/runquantify.py {}/.').format(outdir_name)
    output_handler(subprocess.check_output([bash_command],stderr=subprocess.STDOUT,shell=True))

    bash_command = ('cp analysis/runattempt.py {}/.').format(outdir_name)
    output_handler(subprocess.check_output([bash_command],stderr=subprocess.STDOUT,shell=True))
            
    os.chdir(outdir_name)
    
    bash_command = ('mkdir -p bedgraph')
    output_handler(subprocess.check_output([bash_command],stderr=subprocess.STDOUT,shell=True))
    
    bash_command = ('mkdir -p curvegraph')
    output_handler(subprocess.check_output([bash_command],stderr=subprocess.STDOUT,shell=True))
    
    bash_command = ('mkdir -p processed')
    output_handler(subprocess.check_output([bash_command],stderr=subprocess.STDOUT,shell=True))

    write_analysis_json(outdir_name)
    
    outline = ('\n\n\nRunning initial processing on {}...').format(outdir_name)
    print(outline)
    #sudo
    bash_command = ('python runprocess.py')
    output_handler(subprocess.check_output([bash_command],stderr=subprocess.STDOUT,shell=True))
    
    outline = ('\n\n\nRunning feature quantification step on known uORFs on {}...').format(outdir_name)
    print(outline)
    #sudo
    bash_command = ('python runquantify.py')
    output_handler(subprocess.check_output([bash_command],stderr=subprocess.STDOUT,shell=True))
    
    outline = ('\n\n\nIdentifying potential uORFs in {}...').format(outdir_name)
    print(outline)
    #sudo
    bash_command = ('python runattempt.py')
    output_handler(subprocess.check_output([bash_command],stderr=subprocess.STDOUT,shell=True))
    
    outline = ('Computing features on {}...').format(outdir_name)
    print(outline)
    #sudo
    bash_command = ('python  ../analysis/newcompute_features.py')
    output_handler(subprocess.check_output([bash_command],stderr=subprocess.STDOUT,shell=True))
    
    print('Completed -quantify step')
    
# Task Predict - evaluates the potential uORFs by observed score and null model scores
if args.predict_uorfs:
#sudo
    bash_command = ('python analysis/homology.py -i {}').format(args.input_dir)
        
    if args.known_uorfs:
        add_str = (' -known {}').format(args.known_uorfs)
        bash_command += add_str
        
    output_handler(subprocess.check_output([bash_command],stderr=subprocess.STDOUT,shell=True))
    #
    bash_command = ('cp results/{}-significant-resolved-qvals.bed {}/{}-candidate_uORFs.bed').format(args.input_dir, args.input_dir, args.input_dir)
    output_handler(subprocess.check_output([bash_command],stderr=subprocess.STDOUT,shell=True))
    
    print('Completed -predict step')
